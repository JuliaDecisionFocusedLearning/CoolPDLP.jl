var documenterSearchIndex = {"docs":
[{"location":"api/#API-reference","page":"API reference","title":"API reference","text":"","category":"section"},{"location":"api/#CoolPDLP.Algorithm","page":"API reference","title":"CoolPDLP.Algorithm","text":"Algorithm\n\nFields\n\nconversion::CoolPDLP.ConversionParameters\npreconditioning::CoolPDLP.PreconditioningParameters{T} where T<:Number\nstep_size::CoolPDLP.StepSizeParameters\nrestart::CoolPDLP.RestartParameters\ngeneric::CoolPDLP.GenericParameters\ntermination::CoolPDLP.TerminationParameters\n\n\n\n\n\n","category":"type"},{"location":"api/#CoolPDLP.Algorithm-Union{Tuple{}, Tuple{Type{T}}, Tuple{B}, Tuple{M}, Tuple{Ti}, Tuple{T}, Tuple{A}, Tuple{Type{T}, Type{Ti}}, Tuple{Type{T}, Type{Ti}, Type{M}}} where {A, T, Ti, M, B}","page":"API reference","title":"CoolPDLP.Algorithm","text":"Algorithm{:ALGNAME}(\n    # conversion\n    _T::Type{T} = Float64,\n    ::Type{Ti} = Int,\n    ::Type{M} = SparseMatrixCSC;\n    backend::B = CPU(),\n    # preconditioning\n    chambolle_pock_alpha = 1.0,\n    ruiz_iter = 10,\n    # step sizes\n    invnorm_scaling = 0.9,\n    primal_weight_damping = 0.5,\n    zero_tol = 1.0e-8,\n    # restart\n    sufficient_decay = 0.2,\n    necessary_decay = 0.8,\n    artificial_decay = 0.36,\n    # generic\n    show_progress = false,\n    check_every = 100,\n    record_error_history = true,\n    # termination\n    termination_reltol = 1.0e-4,\n    max_kkt_passes = 10^5,\n    time_limit = 100.0,\n)\n\nConstructor for algorithm configs.\n\n\n\n\n\n","category":"method"},{"location":"api/#CoolPDLP.GPUSparseMatrixCOO","page":"API reference","title":"CoolPDLP.GPUSparseMatrixCOO","text":"GPUSparseMatrixCOO\n\nFields\n\nm::Int64\nn::Int64\nrowval::DenseVector{Ti} where Ti<:Integer\ncolval::DenseVector{Ti} where Ti<:Integer\nnzval::DenseVector{T} where T<:Number\n\n\n\n\n\n","category":"type"},{"location":"api/#CoolPDLP.GPUSparseMatrixCSR","page":"API reference","title":"CoolPDLP.GPUSparseMatrixCSR","text":"GPUSparseMatrixCSR\n\nFields\n\nm::Int64\nn::Int64\nrowptr::DenseVector{Ti} where Ti<:Integer\ncolval::DenseVector{Ti} where Ti<:Integer\nnzval::DenseVector{T} where T<:Number\n\n\n\n\n\n","category":"type"},{"location":"api/#CoolPDLP.GPUSparseMatrixELL","page":"API reference","title":"CoolPDLP.GPUSparseMatrixELL","text":"GPUSparseMatrixELL\n\nFields\n\nm::Int64\nn::Int64\ncolval::DenseMatrix{Ti} where Ti<:Integer\nnzval::DenseMatrix{T} where T<:Number\n\n\n\n\n\n","category":"type"},{"location":"api/#CoolPDLP.MILP","page":"API reference","title":"CoolPDLP.MILP","text":"MILP\n\nRepresent a Mixed Integer Linear Program in \"cuPDLPx form\":\n\nmin cᵀx   s.t.   lv ≤ x ≤ uv\n                 lc ≤ A * x ≤ uc\n\nConstructor\n\nMILP(;\n    c, lv, uv, A, lc, uc,\n    [D1, D2, int_var, var_names, dataset, name, path]\n)\n\nFields\n\nc::DenseVector{T} where T<:Number: objective vector\nlv::DenseVector{T} where T<:Number: variable lower bound\nuv::DenseVector{T} where T<:Number: variable upper bound\nA::AbstractMatrix{T} where T<:Number: constraint matrix\nAt::AbstractMatrix{T} where T<:Number: transposed constraint matrix\nlc::DenseVector{T} where T<:Number: constraint lower bound\nuc::DenseVector{T} where T<:Number: constraint upper bound\nD1::LinearAlgebra.Diagonal{T, V} where {T<:Number, V<:DenseVector{T}}: left preconditioner\nD2::LinearAlgebra.Diagonal{T, V} where {T<:Number, V<:DenseVector{T}}: right preconditioner\nint_var::DenseVector{Bool}: which variables must be integers\nvar_names::Vector{String}: variable names\ndataset::String: source dataset\nname::String: instance name (last part of the path)\npath::String: file path the MILP was read from\n\n\n\n\n\n","category":"type"},{"location":"api/#CoolPDLP.MILP-Tuple{QPSReader.QPSData}","page":"API reference","title":"CoolPDLP.MILP","text":"MILP(qps::QPSData; kwargs...)\n\nConstruct a MILP from a QPSData object generated by QPSReader.jl.\n\n\n\n\n\n","category":"method"},{"location":"api/#CoolPDLP.Optimizer","page":"API reference","title":"CoolPDLP.Optimizer","text":"Optimizer\n\nSolver type compatible with JuMP, which calls an algorithm from CoolPDLP under the hood.\n\nIts options are the same as the keyword arguments of Algorithm.\n\n\n\n\n\n","category":"type"},{"location":"api/#CoolPDLP.PrimalDualSolution","page":"API reference","title":"CoolPDLP.PrimalDualSolution","text":"PrimalDualSolution\n\nFields\n\nx::DenseVector{T} where T<:Number\ny::DenseVector{T} where T<:Number\n\n\n\n\n\n","category":"type"},{"location":"api/#CoolPDLP.PDHG-Tuple","page":"API reference","title":"CoolPDLP.PDHG","text":"PDHG(args...; kwargs...)\n\nShortcut for Algorithm{:PDHG} with some defaults disabled.\n\n\n\n\n\n","category":"method"},{"location":"api/#CoolPDLP.PDLP-Tuple","page":"API reference","title":"CoolPDLP.PDLP","text":"PDLP(args...; kwargs...)\n\nShortcut for Algorithm{:PDLP}.\n\n\n\n\n\n","category":"method"},{"location":"api/#CoolPDLP.initialize","page":"API reference","title":"CoolPDLP.initialize","text":"initialize(milp, sol, algo)\n\nInitialize the appropriate state for solving milp starting from sol with the algorithm defined by algo.\n\n\n\n\n\n","category":"function"},{"location":"api/#CoolPDLP.is_feasible-Tuple{Any, MILP}","page":"API reference","title":"CoolPDLP.is_feasible","text":"is_feasible(x, milp[; cons_tol=1e-6, int_tol=1e-5, verbose=true])\n\nCheck whether solution vector x is feasible for milp.\n\nKeyword arguments\n\ncons_tol: tolerance for constraint satisfaction\nint_tol: tolerance for integrality requirements\nverbose: whether to display warnings\n\n\n\n\n\n","category":"method"},{"location":"api/#CoolPDLP.nbcons-Tuple{MILP}","page":"API reference","title":"CoolPDLP.nbcons","text":"nbcons(milp)\n\nReturn the number of constraints in milp, not including variable bounds or integrality requirements.\n\n\n\n\n\n","category":"method"},{"location":"api/#CoolPDLP.nbcons_eq-Tuple{MILP}","page":"API reference","title":"CoolPDLP.nbcons_eq","text":"nbcons_eq(milp)\n\nReturn the number of equality constraints in milp.\n\n\n\n\n\n","category":"method"},{"location":"api/#CoolPDLP.nbcons_ineq-Tuple{MILP}","page":"API reference","title":"CoolPDLP.nbcons_ineq","text":"nbcons_ineq(milp)\n\nReturn the number of inequality constraints in milp, not including variable bounds.\n\n\n\n\n\n","category":"method"},{"location":"api/#CoolPDLP.nbvar-Tuple{MILP}","page":"API reference","title":"CoolPDLP.nbvar","text":"nbvar(milp)\n\nReturn the number of variables in milp.\n\n\n\n\n\n","category":"method"},{"location":"api/#CoolPDLP.nbvar_cont-Tuple{MILP}","page":"API reference","title":"CoolPDLP.nbvar_cont","text":"nbvar_cont(milp)\n\nReturn the number of integer variables in milp.\n\n\n\n\n\n","category":"method"},{"location":"api/#CoolPDLP.nbvar_int-Tuple{MILP}","page":"API reference","title":"CoolPDLP.nbvar_int","text":"nbvar_int(milp)\n\nReturn the number of integer variables in milp.\n\n\n\n\n\n","category":"method"},{"location":"api/#CoolPDLP.objective_value-Tuple{Any, MILP}","page":"API reference","title":"CoolPDLP.objective_value","text":"objective_value(x, milp)\n\nCompute the value of the linear objective of milp at solution vector x.\n\n\n\n\n\n","category":"method"},{"location":"api/#CoolPDLP.preprocess-Tuple{MILP, PrimalDualSolution, CoolPDLP.Algorithm}","page":"API reference","title":"CoolPDLP.preprocess","text":"preprocess(milp_init, sol_init, algo)\n\nApply preconditioning, type conversion and device transfer to milp_init and sol_init for the algorithm defined by algo.\n\nReturn a tuple (milp, sol).\n\n\n\n\n\n","category":"method"},{"location":"api/#CoolPDLP.solve!","page":"API reference","title":"CoolPDLP.solve!","text":"solve!(state, milp, algo)\n\nModify state in-place to solve the continuous relaxation of milp using the algorithm defined by algo.\n\n\n\n\n\n","category":"function"},{"location":"api/#CoolPDLP.solve-Tuple{MILP, PrimalDualSolution, CoolPDLP.Algorithm}","page":"API reference","title":"CoolPDLP.solve","text":"solve(milp, sol, algo)\nsolve(milp, algo)\n\nSolve the continuous relaxation of milp starting from solution sol using the algorithm defined by algo.\n\nReturn a couple (sol, stats) where sol is the last solution and stats contains convergence information.\n\n\n\n\n\n","category":"method"},{"location":"preconditioning/#Preconditioning","page":"Preconditioning","title":"Preconditioning","text":"","category":"section"},{"location":"preconditioning/#Basic-formulas","page":"Preconditioning","title":"Basic formulas","text":"Original problem P and preconditioned problem tildeP linked by:\n\ntildeA = D_1 A D_2 so A = D_1^-1 tildeA D_2^-1\ntildeA^top = D_2 A^top D_1 so A^top = D_2^-1 tildeA^top D_1^-1\ntildex = D_2^-1 x so x = D_2 tildex\ntildey = D_1^-1 y so y = D_1 tildey, but tildemathcalY = mathcalY\ntilder = D_2 r so r = D_2^-1 tilder, but tildemathcalR = mathcalR\ntildec = D_2 c so c = D_2^-1 tildec\n(tildeell_v tildeu_v) = D_2^-1 (ell_v u_v) so (ell_v u_v) = D_2 (tildeell_v tildeu_v)\n(tildeell_c tildeu_c) = D_1 (ell_c u_c) so (ell_c u_c) = D_1^-1 (tildeell_c tildeu_c)","category":"section"},{"location":"preconditioning/#Error-computation-in-the-original-problem","page":"Preconditioning","title":"Error computation in the original problem","text":"Then we have the following terms in the KKT errors:\n\nbeginalign*\nc - A^top y - r\n = D_2^-1 tildec - D_2^-1 tildeA^top D_1^-1 D_1 tildey - D_2^-1 tilder \n = D_2^-1(tildec - tildeA^top tildey - tilder)\nendalign*\n\nbeginalign*\nAx - mathrmproj_ell_cu_c(Ax)\n = D_1^-1 tildeA D_2^-1 D_2 tildex - mathrmproj_D_1^-1 tildeell_c D_1^-1 tildeu_c (D_1^-1 tildeA D_2^-1 D_2 tildex) \n = D_1^-1 tildeA tildex - mathrmproj_D_1^-1 tildeell_c D_1^-1 tildeu_c (D_1^-1 tildeA tildex) \n = D_1^-1 lefttildeA tildex - mathrmproj_tildeell_c tildeu_c (tildeA tildex)right \nendalign*\n\nr - mathrmproj_mathcalR(r) = D_2^-1 tilder - mathrmproj_tildemathcalR(D_2^-1 tilder) = D_2^-1 (tilder - mathrmproj_tildemathcalR(tilder))\n\nc^top x = (D_2^-1 tildec)^top (D_2 tildex) = tildec^top D_2^-1 D_2 tildex = tildec^top tildex\n\nbeginalign*\np(y ell_c u_c)\n = u_c^top y^+ - ell_c^top y^- \n = (D_1^-1 tildeu_c)^top (D_1 tildey)^+ - (D_1^-1 tildeell_c)^top (D_1 tildey)^- \n = tildeu_c^top D_1^-1 D_1 tildey^+ - tildeell_c^top D_1^-1 D_1 tildey^- \n = tildeu_c^top tildey^+ - tildeell_c tildey^-\nendalign*\n\nbeginalign*\np(r ell_v u_v)\n = u_v^top r^+ - ell_v^top r^- \n = (D_2 tildeu_v)^top (D_2^-1 tilder)^+ - (D_2 tildeell_v)^top (D_2^-1 tilder)^- \n = tildeu_v^top D_2 D_2^-1 tilder^+ - tildeell_v^top D_2 D_2^-1 tilder^- \n = tildeu_v^top tilder^+ - tildeell_v^top tilder^-\nendalign*\n\nWe make use of a few key observations:\n\nProjection on mathcalR commutes with scaling\nProjection on an interval commutes with scaling if scaling is also applied to the interval in question","category":"section"},{"location":"#CoolPDLP.jl","page":"Home","title":"CoolPDLP.jl","text":"(Image: tests) (Image: docs:stable) (Image: docs:dev) (Image: code style: runic) (Image: Aqua QA)\n\nA pure-Julia, hardware-agnostic parallel implementation of Primal-Dual hybrid gradient for Linear Programming (PDLP) and its variants.\n\nThis package is a work in progress, with many features still missing. Please reach out if it doesn't work to your satisfaction.","category":"section"},{"location":"#Getting-started","page":"Home","title":"Getting started","text":"Use Julia's package manager to install CoolPDLP.jl, choosing either the latest stable version\n\npkg> add CoolPDLP\n\nor the development version\n\npkg> add https://github.com/JuliaDecisionFocusedLearning/CoolPDLP.jl\n\nThere are two ways to call the solver: either directly or via its JuMP.jl interface. See the tutorial for details.","category":"section"},{"location":"#Why-a-new-package?","page":"Home","title":"Why a new package?","text":"There are already several open-source implementations of primal-dual algorithms for LPs (not to mention those in commercial solvers). Here is an incomplete list:\n\nPackage Hardware\nFirstOrderLP.jl, or-tools CPU only\ncuPDLP.jl, cuPDLP-c NVIDIA\ncuPDLPx, cuPDLPx.jl NVIDIA\nHPR-LP, HP-LP-C, HPR-LP-PYTHON NVIDIA\nBatchPDLP.jl NVIDIA\nHiGHS NVIDIA\ncuopt NVIDIA\ntorchPDLP agnostic (via PyTorch)\nMPAX agnostic (via JAX)\n\nUnlike cuPDLP and most of its variants, CoolPDLP.jl uses KernelAbstractions.jl to target most common GPU architectures (NVIDIA, AMD, Intel, Apple), as well as plain CPUs. It also allows you to plug in your own sparse matrix types, or experiment with different floating point precisions. That's what makes it so cool.","category":"section"},{"location":"#References","page":"Home","title":"References","text":"PDLP: A Practical First-Order Method for Large-Scale Linear Programming, Applegate et al. (2025)\n\nAn Overview of GPU-based First-Order Methods for Linear Programming and Extensions, Lu & Yang (2025)","category":"section"},{"location":"#Roadmap","page":"Home","title":"Roadmap","text":"See the issue tracker for an overview of planned features.","category":"section"},{"location":"#Acknowledgements","page":"Home","title":"Acknowledgements","text":"Guillaume Dalle was partially funded through a state grant managed by Agence Nationale de la Recherche for France 2030 (grant number ANR-24-PEMO-0001).","category":"section"},{"location":"internals/#Internals","page":"Internals","title":"Internals","text":"These symbols are not part of the public API, their behavior may change without warning between releases.","category":"section"},{"location":"internals/#CoolPDLP.ConstraintMatrix","page":"Internals","title":"CoolPDLP.ConstraintMatrix","text":"ConstraintMatrix\n\nFields\n\nA::SparseArrays.AbstractSparseMatrix{T, Ti} where {T<:Number, Ti<:Integer}\nAt::SparseArrays.AbstractSparseMatrix{T, Ti} where {T<:Number, Ti<:Integer}\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.ConvergenceStats","page":"Internals","title":"CoolPDLP.ConvergenceStats","text":"ConvergenceStats\n\nFields\n\nerr::CoolPDLP.KKTErrors: current KKT error\nstarting_time::Float64: time at which the algorithm started, in seconds\ntime_elapsed::Float64: time elapsed since the algorithm started, in seconds\nkkt_passes::Int64: number of multiplications by both the KKT matrix and its transpose\ntermination_status::CoolPDLP.TerminationStatus: termination stats (should be STILL_RUNNING until the algorithm actually terminates)\nerror_history::Array{Tuple{Int64, CoolPDLP.KKTErrors{T}}, 1} where T<:Number\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.ConversionParameters","page":"Internals","title":"CoolPDLP.ConversionParameters","text":"ConversionParameters{T,Ti,M}\n\nType parameters\n\nT: floating point type to convert values to\nTi: integer type to convert indices to\nM: matrix constructor to use on the constraints\n\nFields\n\nbackend::KernelAbstractions.Backend: CPU or GPU backend used for computations\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.GenericParameters","page":"Internals","title":"CoolPDLP.GenericParameters","text":"GenericParameters\n\nFields\n\nshow_progress::Bool: whether to show a progress bar\ncheck_every::Int64: frequency of restart or termination checks\nrecord_error_history::Bool: whether or not to record error evolution\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.KKTErrors","page":"Internals","title":"CoolPDLP.KKTErrors","text":"KKTErrors\n\nFields\n\nprimal::Number: primal feasibility error\nprimal_scale::Number: characteristic scale of the primal constraint RHS\ndual::Number: dual feasibility error\ndual_scale::Number: characteristic scale of the dual constraint RHS\ngap::Number: primal-dual gap\ngap_scale::Number: characteristic scale of the gap\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.PDHGState","page":"Internals","title":"CoolPDLP.PDHGState","text":"PDHGState\n\nFields\n\nsol::PrimalDualSolution: current solution\nsol_last::PrimalDualSolution: last solution\nstep_sizes::CoolPDLP.StepSizes: step sizes\nscratch::CoolPDLP.Scratch: scratch space\nstats::CoolPDLP.ConvergenceStats: convergence stats\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.PDLPState","page":"Internals","title":"CoolPDLP.PDLPState","text":"PDHGState\n\nFields\n\nsol::PrimalDualSolution: current solution\nsol_last::PrimalDualSolution: last solution\nsol_avg::PrimalDualSolution: current average solution\nsol_avg_last::PrimalDualSolution: last average solution\nsol_restart::PrimalDualSolution: solution from last restart\nstep_sizes::CoolPDLP.StepSizes: step sizes\nscratch::CoolPDLP.Scratch: scratch space\niteration::CoolPDLP.IterationCounter: iteration counter\nrestart_stats::CoolPDLP.RestartStats: restart stats\nstats::CoolPDLP.ConvergenceStats: convergence stats\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.Preconditioner","page":"Internals","title":"CoolPDLP.Preconditioner","text":"Preconditioner\n\nFields\n\nD1::LinearAlgebra.Diagonal{T, V} where {T<:Number, V<:DenseVector{T}}: left preconditioner\nD2::LinearAlgebra.Diagonal{T, V} where {T<:Number, V<:DenseVector{T}}: right preconditioner\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.PreconditioningParameters","page":"Internals","title":"CoolPDLP.PreconditioningParameters","text":"PreconditioningParameters\n\nFields\n\nchambolle_pock_alpha::Any: norm parameter in the Chambolle-pock preconditioner\nruiz_iter::Int64: iteration parameter in the Ruiz preconditioner\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.RestartParameters","page":"Internals","title":"CoolPDLP.RestartParameters","text":"RestartParameters\n\nFields\n\nsufficient_decay::Number: restart criterion: sufficient decay in normalized duality gap\nnecessary_decay::Number: restart criterion: necessary decay\nartificial_decay::Number: restart criterion: long inner loop\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.RestartStats","page":"Internals","title":"CoolPDLP.RestartStats","text":"RestartStats\n\nFields\n\nrestart_from_avg::Bool\nerr_candidate::CoolPDLP.KKTErrors\nerr_candidate_last::CoolPDLP.KKTErrors\nerr_restart::CoolPDLP.KKTErrors\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.StepSizeParameters","page":"Internals","title":"CoolPDLP.StepSizeParameters","text":"StepSizeParameters\n\nFields\n\ninvnorm_scaling::Number: scaling of the inverse spectral norm of A when defining the non-adaptive step size\nprimal_weight_damping::Number: primal weight update damping\nzero_tol::Number: tolerance in absolute comparisons to zero\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.StepSizes","page":"Internals","title":"CoolPDLP.StepSizes","text":"StepSizes\n\nFields\n\nη::Number: step size\nη_sum::Number: cumulated step size since last restart\nω::Number: primal weight\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.Symmetrized","page":"Internals","title":"CoolPDLP.Symmetrized","text":"Symmetrized\n\nRepresent a symmetric matrix Kᵀ * K lazily.\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.TerminationParameters","page":"Internals","title":"CoolPDLP.TerminationParameters","text":"TerminationParameters\n\nFields\n\ntermination_reltol::Number: tolerance on KKT relative errors to decide termination\nmax_kkt_passes::Int64: maximum number of multiplications by both the KKT matrix K and its transpose Kᵀ\ntime_limit::Float64: time limit in seconds\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.TerminationStatus","page":"Internals","title":"CoolPDLP.TerminationStatus","text":"TerminationStatus\n\nEnum for the various ways that an algorithm can terminate.\n\nPossible values:\n\nOPTIMAL\nTIME_LIMIT\nITERATION_LIMIT\nSTILL_RUNNING\n\n\n\n\n\n","category":"type"},{"location":"internals/#CoolPDLP.##MILP_simulator#406-Tuple{QPSReader.QPSData}","page":"Internals","title":"CoolPDLP.##MILP_simulator#406","text":"MILP(qps::QPSData; kwargs...)\n\nConstruct a MILP from a QPSData object generated by QPSReader.jl.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##PDHG_simulator#605-Tuple","page":"Internals","title":"CoolPDLP.##PDHG_simulator#605","text":"PDHG(args...; kwargs...)\n\nShortcut for Algorithm{:PDHG} with some defaults disabled.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##PDLP_simulator#615-Tuple","page":"Internals","title":"CoolPDLP.##PDLP_simulator#615","text":"PDLP(args...; kwargs...)\n\nShortcut for Algorithm{:PDLP}.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##combine_simulator#374-Tuple{Number, Number}","page":"Internals","title":"CoolPDLP.##combine_simulator#374","text":"combine(l, u)\n\nReturn the largest finite absolute value between the two bounds, or zero if neither is finite.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##common_backend_simulator#278-Union{NTuple{N, Any}, Tuple{N}} where N","page":"Internals","title":"CoolPDLP.##common_backend_simulator#278","text":"common_backend(args...)\n\nReturn the common GPU backend of several arguments, if it exists, and throw an error otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##is_feasible_simulator#433-Tuple{Any, MILP}","page":"Internals","title":"CoolPDLP.##is_feasible_simulator#433","text":"is_feasible(x, milp[; cons_tol=1e-6, int_tol=1e-5, verbose=true])\n\nCheck whether solution vector x is feasible for milp.\n\nKeyword arguments\n\ncons_tol: tolerance for constraint satisfaction\nint_tol: tolerance for integrality requirements\nverbose: whether to display warnings\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##nbcons_eq_simulator#425-Tuple{MILP}","page":"Internals","title":"CoolPDLP.##nbcons_eq_simulator#425","text":"nbcons_eq(milp)\n\nReturn the number of equality constraints in milp.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##nbcons_ineq_simulator#428-Tuple{MILP}","page":"Internals","title":"CoolPDLP.##nbcons_ineq_simulator#428","text":"nbcons_ineq(milp)\n\nReturn the number of inequality constraints in milp, not including variable bounds.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##nbcons_simulator#422-Tuple{MILP}","page":"Internals","title":"CoolPDLP.##nbcons_simulator#422","text":"nbcons(milp)\n\nReturn the number of constraints in milp, not including variable bounds or integrality requirements.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##nbvar_cont_simulator#419-Tuple{MILP}","page":"Internals","title":"CoolPDLP.##nbvar_cont_simulator#419","text":"nbvar_cont(milp)\n\nReturn the number of integer variables in milp.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##nbvar_int_simulator#416-Tuple{MILP}","page":"Internals","title":"CoolPDLP.##nbvar_int_simulator#416","text":"nbvar_int(milp)\n\nReturn the number of integer variables in milp.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##nbvar_simulator#413-Tuple{MILP}","page":"Internals","title":"CoolPDLP.##nbvar_simulator#413","text":"nbvar(milp)\n\nReturn the number of variables in milp.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##objective_value_simulator#436-Tuple{Any, MILP}","page":"Internals","title":"CoolPDLP.##objective_value_simulator#436","text":"objective_value(x, milp)\n\nCompute the value of the linear objective of milp at solution vector x.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##preprocess_simulator#591-Tuple{MILP, PrimalDualSolution, CoolPDLP.Algorithm}","page":"Internals","title":"CoolPDLP.##preprocess_simulator#591","text":"preprocess(milp_init, sol_init, algo)\n\nApply preconditioning, type conversion and device transfer to milp_init and sol_init for the algorithm defined by algo.\n\nReturn a tuple (milp, sol).\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##proj_multiplier_simulator#371-Union{Tuple{T}, Tuple{T, T, T}} where T<:Number","page":"Internals","title":"CoolPDLP.##proj_multiplier_simulator#371","text":"proj_multiplier(λ, l, u)\n\nProject λ onto the feasible space of the (double) Lagrange multiplier λ⁺ - λ⁻ associated with the constraint l ≤ x ≤ u, where l and/or u might be infinite.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##set_eltype_simulator#456-Union{Tuple{T}, Tuple{Type{T}, AbstractArray{<:AbstractFloat}}} where T","page":"Internals","title":"CoolPDLP.##set_eltype_simulator#456","text":"set_eltype(T, milp)\n\nChange the element type of floating-point containers inside milp to T.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##set_indtype_simulator#466-Union{Tuple{Ti}, Tuple{Type{Ti}, AbstractArray{<:Integer}}} where Ti","page":"Internals","title":"CoolPDLP.##set_indtype_simulator#466","text":"set_indtype(Ti, milp)\n\nChange the element type of integer containers inside milp to Ti.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##set_matrix_type_simulator#476-Union{Tuple{M}, Tuple{Type{M}, MILP}} where M","page":"Internals","title":"CoolPDLP.##set_matrix_type_simulator#476","text":"set_matrix_type(::Type{M}, milp)\n\nConvert the sparse matrices inside milp using constructor M.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##solve_simulator#595-Tuple{MILP, PrimalDualSolution, CoolPDLP.Algorithm}","page":"Internals","title":"CoolPDLP.##solve_simulator#595","text":"solve(milp, sol, algo)\nsolve(milp, algo)\n\nSolve the continuous relaxation of milp starting from solution sol using the algorithm defined by algo.\n\nReturn a couple (sol, stats) where sol is the last solution and stats contains convergence information.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##sort_rows_columns_simulator#530-Tuple{MILP}","page":"Internals","title":"CoolPDLP.##sort_rows_columns_simulator#530","text":"sort_rows_columns(milp)\n\nReturn a new MILP where the constraint matrix has been permuted by order of increasing column and row density.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.##spectral_norm_simulator#387-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Internals","title":"CoolPDLP.##spectral_norm_simulator#387","text":"spectral_norm(K, Kᵀ)\n\nCompute the spectral norm of K with the power method from IterativeSolvers.jl.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.combine-Tuple{Number, Number}","page":"Internals","title":"CoolPDLP.combine","text":"combine(l, u)\n\nReturn the largest finite absolute value between the two bounds, or zero if neither is finite.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.common_backend-Union{NTuple{N, Any}, Tuple{N}} where N","page":"Internals","title":"CoolPDLP.common_backend","text":"common_backend(args...)\n\nReturn the common GPU backend of several arguments, if it exists, and throw an error otherwise.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.proj_multiplier-Union{Tuple{T}, Tuple{T, T, T}} where T<:Number","page":"Internals","title":"CoolPDLP.proj_multiplier","text":"proj_multiplier(λ, l, u)\n\nProject λ onto the feasible space of the (double) Lagrange multiplier λ⁺ - λ⁻ associated with the constraint l ≤ x ≤ u, where l and/or u might be infinite.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.set_eltype-Union{Tuple{T}, Tuple{Type{T}, AbstractArray{<:AbstractFloat}}} where T","page":"Internals","title":"CoolPDLP.set_eltype","text":"set_eltype(T, milp)\n\nChange the element type of floating-point containers inside milp to T.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.set_indtype-Union{Tuple{Ti}, Tuple{Type{Ti}, AbstractArray{<:Integer}}} where Ti","page":"Internals","title":"CoolPDLP.set_indtype","text":"set_indtype(Ti, milp)\n\nChange the element type of integer containers inside milp to Ti.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.set_matrix_type-Union{Tuple{M}, Tuple{Type{M}, MILP}} where M","page":"Internals","title":"CoolPDLP.set_matrix_type","text":"set_matrix_type(::Type{M}, milp)\n\nConvert the sparse matrices inside milp using constructor M.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.sort_rows_columns-Tuple{MILP}","page":"Internals","title":"CoolPDLP.sort_rows_columns","text":"sort_rows_columns(milp)\n\nReturn a new MILP where the constraint matrix has been permuted by order of increasing column and row density.\n\n\n\n\n\n","category":"method"},{"location":"internals/#CoolPDLP.spectral_norm-Tuple{AbstractMatrix{<:Number}, AbstractMatrix{<:Number}}","page":"Internals","title":"CoolPDLP.spectral_norm","text":"spectral_norm(K, Kᵀ)\n\nCompute the spectral norm of K with the power method from IterativeSolvers.jl.\n\n\n\n\n\n","category":"method"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"using CoolPDLP\nusing HiGHS: HiGHS\nusing JLArrays\nusing JuMP: JuMP, MOI\nusing MathOptBenchmarkInstances: Netlib, list_instances, read_instance","category":"section"},{"location":"tutorial/#Creating-a-MILP","page":"Tutorial","title":"Creating a MILP","text":"You can use QPSReader.jl to read a MILP from a local MPS file, or MathOptBenchmarkInstances.jl to automatically download standard benchmark sets (which we do here).\n\ndataset = Netlib\nlist = list_instances(dataset)\nname = list[4]\nqps, path = read_instance(dataset, name);\nnothing #hide\n\nA MILP object can be constructed from there:\n\nmilp = MILP(qps; dataset, name, path)\n\nIts attributes can be queried:\n\nnbvar(milp)\n\nnbcons(milp)\n\nNote that manual construction is also an option if you provide the constraints, variable bounds and objectives as arrays.","category":"section"},{"location":"tutorial/#Solving-a-MILP","page":"Tutorial","title":"Solving a MILP","text":"You can use the PDLP algortithm to solve the continuous relaxation of a MILP. The first thing to do is define parameters inside a PDLP struct.\n\nalgo = PDLP(;\n    termination_reltol = 1.0e-6,\n    time_limit = 10.0,\n)\n\nThen all it takes is to call solve.\n\nsol, stats = solve(milp, algo);\nnothing #hide\n\nThe solution is available as a PrimalDualSolution:\n\nsol.x\n\nThe stats contain information about the convergence of the algorithm:\n\nstats\n\nYou can check the feasibility and objective value:\n\nis_feasible(sol.x, milp; cons_tol = 1.0e-4)\n\nobjective_value(sol.x, milp)","category":"section"},{"location":"tutorial/#Running-on-the-GPU","page":"Tutorial","title":"Running on the GPU","text":"To run the same algorithm on the GPU, all it takes is to define a different set of parameters and thus force conversion of the instance:\n\nalgo_gpu = PDLP(\n    Float32,  # desired float type\n    Int32,  # desired int type\n    GPUSparseMatrixCSR;  # GPU sparse matrix type, replace with e.g. CuSparseMatrixCSR\n    backend = JLBackend(),  # replace with e.g. CUDABackend()\n    termination_reltol = 1.0f-6,\n    time_limit = 10.0,\n)\n\nThe result of the algorithm will live on the GPU:\n\nsol_gpu, stats_gpu = solve(milp, algo_gpu)\nsol_gpu.x\n\nTo bring in back to the CPU, just call the Array converter.\n\nobjective_value(Array(sol_gpu.x), milp)","category":"section"},{"location":"tutorial/#Using-the-JuMP-interface","page":"Tutorial","title":"Using the JuMP interface","text":"If you have a model available in JuMP.jl, you can simply choose CoolPDLP.Optimizer as your solver, and pass it the same options as before.\n\nmodel = JuMP.read_from_file(path; format = MOI.FileFormats.FORMAT_MPS)\nJuMP.set_optimizer(model, CoolPDLP.Optimizer)\nJuMP.set_silent(model)\nJuMP.set_attribute(model, \"termination_reltol\", 1.0e-6)\nJuMP.set_attribute(model, \"matrix_type\", GPUSparseMatrixCSR)\nJuMP.set_attribute(model, \"backend\", JLBackend())\nJuMP.optimize!(model)\nx_jump = JuMP.value.(JuMP.all_variables(model))\n\nobjective_value(x_jump, milp)","category":"section"},{"location":"tutorial/#Comparing-with-HiGHS","page":"Tutorial","title":"Comparing with HiGHS","text":"To check our solution, let's compare it with the output from the HiGHS solver:\n\nmodel_highs = JuMP.read_from_file(path; format = MOI.FileFormats.FORMAT_MPS)\nJuMP.set_optimizer(model_highs, HiGHS.Optimizer)\nJuMP.set_silent(model_highs)\nJuMP.optimize!(model_highs)\nx_ref = JuMP.value.(JuMP.all_variables(model_highs))\n\nOf course, the solution given by HiGHS is feasible too, and we can compare objective values:\n\nis_feasible(x_ref, milp; cons_tol = 1.0e-4)\n\nobjective_value(x_ref, milp)\n\n\n\nThis page was generated using Literate.jl.","category":"section"}]
}
